Пользователь по умолчанию: postgres
Пароль устанавливается при установке

psql -U postgres // войти в консоль postgres под корневым пользователем

Если появляется ПРЕДУПРЕЖДЕНИЕ: "Кодовая страница консоли (866) отличается от основной страницы Windows (1251)". {
	Полный текст: {
		ПРЕДУПРЕЖДЕНИЕ: Кодовая страница консоли (866) отличается от основной
					страницы Windows (1251).
					8-битовые (русские) символы могут отображаться некорректно.
					Подробнее об этом смотрите документацию psql, раздел
					"Notes for Windows users".
	}
	Исправление: {
		написать в консоли "chcp 1251" или другой код, в зависимости от кодировки
	}
}

create database myDatabase;
drop database myDatabase;

CREATE SCHEMA schemaName // создать схему

\list { // показать список баз данных
	\l // синоним
}
\dn // показать список схем
\connect myDatabase { // Подключиться к БД 
	\c myDatabase //  синоним
}
\dt // показать список таблиц

Типы данных {
	CHARACTER VARYING 	// строковый тип
	CHARACTER VARYING 	// то же самое, но с указанием ораничения по числу символов
	varchar 			// синоним для строки. Получается всё равно CHARACTER VARYING
	varchar(50)			// то же с ограничением
	INTEGER				// целочисленный
	int					// то же самое
	serial				// можно указать вместо типа - тогда это будет целочисленный с автоинкрементом
}

create table {

	// пример создания таблицы
	CREATE TABLE customers
	(
		Id SERIAL PRIMARY KEY,
		FirstName CHARACTER VARYING(30),
		LastName CHARACTER VARYING(30),
		Email CHARACTER VARYING(30),
		Age INTEGER
	);
	
	Автоинкремент {
		SERIAL - синтаксическая контрукция, которая создаёт поле типа int с автоинкрементом
		В последнийх версиях рекомендуется использовать вместо SERIAL слеующей конструкцией:
		GENERATED BY DEFAULT AS IDENTITY
		То есть код содания таблицы будет выглядеть так:

		CTREATE TABLE Person(
			id int GENERATED BY DEFAULT AS IDENTITY,
			name varchar,
			age int,
			email varchar
		)

		// Добавляем PRIMART KEY - Алишев говорит, что это нормально
		CTREATE TABLE Person(
			id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			name varchar,
			age int,
			email varchar
		)

	}
	
	Constraints (Ограничения) {
		UNIQUE // уникальность
		NOT NULL
		PRIMARY KEY { // включает в себя два ограничения сразу:
			UNIQUE
			NOT NULL
		}
		FOREIGN KEY {
			UNIQUE 		// ? в таблице может быть несколько записей с одним и тем же FOREIN KEY. Возможно строить удалить эту строчку
			NOT NULL
		}
		CHECK (условие) // Можно указать какое-то условие
		
		Пример:
		CREATE TABLE customers
		(
			Id SERIAL PRIMARY KEY,
			FirstName CHARACTER VARYING(30) NOT NULL,
			LastName CHARACTER VARYING(30) NOT NULL,
			Email CHARACTER VARYING(30) NOT NULL UNIQUE,
			Age INTEGER CHECK (age > 0)
		);
	}

	Составной ключ {
		Исключает добавление двух записей, у которых одинаковы два поля соответственно
		Пример:
			CREATE TABLE Actor_Movie(
				actor_id REFEFRENCES Actor(actor_id),
				movie_id REFEFRENCES Movie(movie_id),
				PRIMARY KEY (actor_id, movie_id)	// PRIMARY KEY указывается не как обычно, а в отдельной строке, чтобы сделать его составным
			)
	}

	Отношения и ключи {
		Для добавления связи используется слово REFERENCES 
		в зависимой (child) таблице на колонке, 
		где указывается внешний id. 
		Это и будет forein key.
		
		One to one {
			Для связи One to one RREFERENCES указывается на PRIMARY KEY в child таблице.
			Значит внешний id будет и внутренним.
			Пример:
			CREATE TABLE Person(
				person_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
				name VARCHAR(100)
			);
			CREATE TABLE Passport(
				person_id int PRIMARY KEY REFEFRENCES Person(person_id), // указываем REFERENCES на PRIMARY KEY
				name VARCHAR(100)
			);
		}
			
		One to many {
			Для связи One to many REFERENCES указывается на отдельном столбце.
			Свой PRIMARY KEY  в child таблице делается как обычно
			Пример:
			CREATE TABLE Director(
				director_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
				name VARCHAR(100)
			);
			CREATE TABLE Movie(
				movie_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
				director_id int REFERENCES Director(director_id),		// указываем на что именно ссылаемся
				name VARCHAR(200)
			)
		}
		
		Many to many {
			Для связи Many to many REFERENCES указывается во внешней таблице у двух столбцов
			Чтобы не было дублей записей, рекомендуется добавить составной первичный ключ, который будет состоять из двух внешних
			Пример:
			CREATE TABLE Actor_Movie(
				actor_id REFEFRENCES Actor(actor_id),
				movie_id REFEFRENCES Movie(movie_id),
				PRIMARY KEY (actor_id, movie_id)		// PRIMARY KEY указывается не как обычно, а в отдельной строке, чтобы сделать его составным
			)
		}
	}
	
	Каскадирование {
		Что делать, если попробовать удалить строку из одной таблицы, а строка из другой таблицы будет ссылаться на удаляемую?
		3 стратегии:
			RESTRICT 	// запрещает удаление - по умолчанию
			CASCADE		// удаляет все зависимые строки из других таблиц
			SET NULL	// оставляет в зависимой строке null
		Указывается со словом ON DELETE ...
		Пример:
		CREATE TABLE Director(
			director_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			name VARCHAR(100)
		);
		CREATE TABLE Movie(
			movie_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			director_id int REFERENCES Director(director_id) ON DELETE CASCADE,	// указываем стратегию
			name VARCHAR(200)
		)
		
	}

}


\d tableName // DESCRIBE TABLE

alter table // также как в MySQL

// изменить ограничение. В данном случае изменение десвтия при удалении сущности, на которую ссылаются в другой таблице
ALTER TABLE tableName
DROP CONSTRAINT constraintName,
ADD CONSTRAINT constraintName
   FOREIGN KEY (id)
   REFERENCES games(inotherTableId)
   ON DELETE CASCADE; 		// или RESTRINC или SET NULL

TRUNCATE tableName; // очистить данные в таблице

INSERT INTO Products VALUES (1, 'Galaxy S9', 'Samsung', 4, 63000);
Another example {
	insert into shit(name, age) values ('Tim', 10);
	insert into shit(name, age) values ('Sam', 15), ('John', 35);
	
	About table: {
		Was created by:
		create table shit(id serial primary key, name character varying(30), age integer);
	}
}

UPDATE {
	
	UPDATE tableName SET columnName = 'example@test.ru' WHERE ...;
	
	Пример:
	UPDATE shit SET email = 'example@test.ru' WHERE id = 1;
	UPDATE shit SET email = 'Fuck@You.ru', age = 99 WHERE id = 3;	// несколько колонок
}

DELETE {
		DELETE FROM table_name WHERE условие; // удаление одной сроки из таблицы
		Пример: DELETE FROM book WHERE id = 1;
}
	
view {
	CREATE VIEW viewName AS selectStatement;
	CREATE VIEW viewName (newColumnNameInViewForFirstColumn, sameForSecond) AS selectStatement; // названий новых колонок может быть меньше, но не больше.
	
	
	Пример:
	create view pp (na, num) as select name, number from person join passport on passport.some_id = person.id;
	
}